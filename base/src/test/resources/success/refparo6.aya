-- https://github.com/aya-prover/aya-dev/issues/8
prim I prim left prim right prim arcoe
struct Path (A : I -> Type) (a : A left) (b : A right) : ooType
 | at (i : I) : A i {
   | left => a
   | right => b
 }
def path {A : I -> Type} (p : Pi (i : I) -> A i)
  => new Path A (p left) (p right) { | at i => p i }
def `=` Eq {A : Type} (a b : A) : ooType => Path (\ i => A) a b
def idp {A : Type} (a : A) : a = a => path (\ i => a)
def coe {a b : Type} (eq : a = b) (x : a) (i : I) : eq.at i
  => arcoe eq.at x i

bind = looser application

open data Unit : Set 0 | unit

open data Entity : Set 0
  | john

struct EventT : Set 1
  | agentT : Set 0

def getAgentT (t : EventT) : Set 0 => t.agentT
def setAgentT (x : Set 0) (t : EventT) : EventT
  => new EventT { | agentT => x }
def agentT-inv {t : EventT} {u : Set 0} : (setAgentT u t).agentT = u
  => idp u

struct Event (t : EventT) : Set 2
  | agent : t.agentT

def getAgent (t : EventT) (e : Event t) : t.agentT => e.agent

open data RunImpl (ag : Entity) : Set 0
  | john => run1

def Run (e : Event (new EventT { | agentT => Entity })) : Set 3
  => RunImpl e.agent

def mkVerb {t : EventT} (p : Event t -> Set 3) : (Event t -> Set 3) -> Set 3
  => \f => Sig (e : Event t) ** (Sig (p e) ** (f e))

def run : (Event (new EventT { | agentT => Entity }) -> Set 3) -> Set 3
  => mkVerb {new EventT { | agentT => Entity }} Run

def mkTheta
  (getT : EventT -> Set 0)
  (get : Pi (t : EventT) -> Event t -> getT t)
  (setT : Set 0 -> EventT -> EventT)
  (invariant : Pi {t : EventT} {u : Set 0} -> u = getT (setT u t))
  : Pi {u : Set 0} {t : EventT}
  -> ((u -> ooType 3) -> ooType 3)
  -> ((Event (setT u t) -> ooType 3) -> ooType 3)
  -> (Event (setT u t) -> ooType 3) -> ooType 3
  => \{u} {t} => \q p => \f =>
    q (\x => p (\e => Sig (get (setT u t) e = coe invariant x right) ** (f e)))

def agent' :
  Pi {u : Set 0} {t : EventT}
  -> ((u -> ooType 3) -> ooType 3)
  -> ((Event (setAgentT u t) -> ooType 3) -> ooType 3)
  -> (Event (setAgentT u t) -> ooType 3) -> ooType 3
  => \{u} {t} => mkTheta getAgentT getAgent setAgentT (\{t'} {u'} => agentT-inv {t'} {u'}) {u} {t}

def mkConst {t : Set} (x : t) : (t -> ooType 3) -> ooType 3
  => \f => f x

def john' : (Entity -> ooType 3) -> ooType 3
  => mkConst john

def mkSentence {t : EventT} (p : (Event t -> ooType 3) -> ooType 3) : ooType 3
  => p (\x => Unit)

def john-runs : ooType 3 =>
  mkSentence {new EventT { | agentT => Entity }}
    (agent' {Entity} {new EventT { | agentT => Unit }} john' run)

def proof-john-runs-event : Event (new EventT { | agentT => Entity })
  => new Event (new EventT { | agentT => Entity }) { | agent => john }
def proof-john-runs : john-runs => (proof-john-runs-event, (run1, (idp john, unit)))
