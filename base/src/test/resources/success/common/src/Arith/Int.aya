open import Arith::Nat
open import Data::Bool
open import Paths

open data Int
| signed Bool Nat
| posneg (i : I) { i := pos 0 | ~ i := neg 0 }

def pos => signed true
def neg => signed false

def negate Int : Int
| signed b n => signed (not b) n
| posneg i => posneg (~ i)

def succInt Int : Int
| signed true n => pos (suc n)
| signed false (suc n) => neg n
| signed false zero => pos 1
| posneg i => pos 1

-- TODO: reimplement using univalence
def predInt (x : Int) : Int => negate (succInt (negate x))

-- CHECK: this require showing `neg 0 = pos 0` definitionally for confluence check,
-- which is not possible for higher inductive types?
{-
def overlap subNI (a b : Nat) : Int
| 0, a => neg a
| a, 0 => pos a
| suc a, suc b => subNI a b
-}

def addI Int Int : Int
| signed _ 0, n => n
| posneg _, n => n
-- CHECK: we need to write out `signed true ...` here,
-- because the termination checker cannot unfold definition yet?
| signed true (suc m), n => succInt (addI (signed true m) n)
| signed false (suc m), n => predInt (addI (signed false m) n)

{-
def addI-comm (a b : Int) : addI a b = addI b a
| pos n, pos m => pmap pos (+-comm n m)
| neg n, neg m => pmap neg (+-comm n m)
| pos n, neg m => idp
| neg n, pos m => idp
-}
